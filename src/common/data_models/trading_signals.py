"""
Trading Signal Data Models

This module contains dataclasses for trading signals generated by the weather service
and consumed by the tracker for execution. This centralizes all trading logic in the
weather service while keeping the tracker as a pure execution engine.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional, cast

from common.constants.trading import MAX_PRICE_CENTS, MIN_PRICE_CENTS
from common.validation_guards import require

from .trading import OrderAction, OrderSide

# Error messages
ERR_SIGNAL_COUNT_MISMATCH = "signals_generated ({generated}) must match actual signals count ({actual})"
ERR_UPDATE_TIMESTAMP_NOT_DATETIME = "Update timestamp must be a datetime object"
ERR_MARKETS_ANALYZED_NEGATIVE = "Total markets analyzed cannot be negative"


class TradingSignalType(Enum):
    """Type of trading signal"""

    BUY = "buy"
    SELL = "sell"
    NO_TRADE = "no_trade"


@dataclass
class TradingSignal:
    """
    Optimized trading signal for Redis HASH storage with market data.

    Contains essential fields for trade execution. Redundant pricing data
    (theoretical_value_cents, market_price_cents) removed as they're available
    in the market hash. Weather station derivable from ticker pattern.
    """

    # Core trading instruction
    signal_type: TradingSignalType
    action: Optional[OrderAction]  # None if signal_type is NO_TRADE
    side: Optional[OrderSide]  # None if signal_type is NO_TRADE
    target_price_cents: Optional[int]  # None if signal_type is NO_TRADE

    # Signal metadata
    ticker: str
    confidence: str  # "HIGH" or "MEDIUM"
    timestamp: datetime

    # Weather context and reasoning
    weather_reason: str  # Human-readable explanation of weather conditions
    trading_reason: str  # Human-readable explanation of why this trade is profitable

    # Essential weather data that triggered the signal
    current_temperature_f: Optional[float]
    strike_threshold: Optional[float]

    # Expected profit for execution validation (derived from market vs theoretical)
    expected_profit_cents: Optional[int]

    def __post_init__(self):
        """Validate trading signal data integrity."""
        self._validate_trade_fields()
        self._validate_reason_fields()
        timestamp_value = cast(object, self.timestamp)
        require(
            isinstance(timestamp_value, datetime),
            ValueError("Timestamp must be a datetime object"),
        )

    def _validate_trade_fields(self) -> None:
        """Ensure trading instructions align with the signal type."""
        if self.signal_type in (TradingSignalType.BUY, TradingSignalType.SELL):
            require(
                self.action is not None and self.side is not None and self.target_price_cents is not None,
                ValueError("BUY/SELL signals must have action, side, and target_price_cents"),
            )
            self._validate_target_price()
            return

        if self.signal_type == TradingSignalType.NO_TRADE:
            require(
                self.action is None and self.side is None and self.target_price_cents is None,
                ValueError("NO_TRADE signals must not have action, side, or target_price_cents"),
            )

    def _validate_target_price(self) -> None:
        """Ensure the provided target price is within the allowed range."""
        assert self.target_price_cents is not None
        target_price = self.target_price_cents
        require(
            MIN_PRICE_CENTS <= target_price <= MAX_PRICE_CENTS,
            ValueError(f"Target price must be between {MIN_PRICE_CENTS}-{MAX_PRICE_CENTS} cents: {target_price}"),
        )

    def _validate_reason_fields(self) -> None:
        """Ensure metadata fields are populated."""
        require(bool(self.ticker), ValueError("Ticker must be specified"))
        require(
            self.confidence in ("HIGH", "MEDIUM"),
            ValueError(f"Confidence must be 'HIGH' or 'MEDIUM', got: {self.confidence!r}"),
        )
        require(bool(self.weather_reason), ValueError("Weather reason must be specified"))
        require(bool(self.trading_reason), ValueError("Trading reason must be specified"))


@dataclass
class TradingSignalBatch:
    """
    Batch of trading signals generated in a single weather update cycle.

    Allows the weather service to generate multiple signals efficiently
    and provides context about the overall update.
    """

    signals: list[TradingSignal]
    weather_station: str
    update_timestamp: datetime
    total_markets_analyzed: int
    signals_generated: int

    def __post_init__(self):
        """Validate batch data integrity"""
        if self.signals_generated != len(self.signals):
            raise ValueError(ERR_SIGNAL_COUNT_MISMATCH.format(generated=self.signals_generated, actual=len(self.signals)))

        timestamp_value = cast(object, self.update_timestamp)
        if not isinstance(timestamp_value, datetime):
            raise TypeError(ERR_UPDATE_TIMESTAMP_NOT_DATETIME)

        if self.total_markets_analyzed < 0:
            raise ValueError(ERR_MARKETS_ANALYZED_NEGATIVE)
