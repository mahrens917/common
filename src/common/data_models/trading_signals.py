"""
Trading Signal Data Models

This module contains dataclasses for trading signals generated by the weather service
and consumed by the tracker for execution. This centralizes all trading logic in the
weather service while keeping the tracker as a pure execution engine.
"""

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional, cast

from common.validation_guards import require

from .trading import OrderAction, OrderSide

# Error messages
ERR_SIGNAL_COUNT_MISMATCH = (
    "signals_generated ({generated}) must match actual signals count ({actual})"
)
ERR_UPDATE_TIMESTAMP_NOT_DATETIME = "Update timestamp must be a datetime object"
ERR_MARKETS_ANALYZED_NEGATIVE = "Total markets analyzed cannot be negative"


# Constants
_MIN_PRICE = 0
_MAX_PRICE = 99


class TradingSignalType(Enum):
    """Type of trading signal"""

    BUY = "buy"
    SELL = "sell"
    NO_TRADE = "no_trade"


@dataclass
class TradingSignal:
    """
    Optimized trading signal for Redis HASH storage with market data.

    Contains essential fields for trade execution. Redundant pricing data
    (theoretical_value_cents, market_price_cents) removed as they're available
    in the market hash. Weather station derivable from ticker pattern.
    """

    # Core trading instruction
    signal_type: TradingSignalType
    action: Optional[OrderAction]  # None if signal_type is NO_TRADE
    side: Optional[OrderSide]  # None if signal_type is NO_TRADE
    target_price_cents: Optional[int]  # None if signal_type is NO_TRADE

    # Signal metadata
    ticker: str
    confidence: str  # "HIGH", "MEDIUM", "LOW"
    timestamp: datetime

    # Weather context and reasoning
    weather_reason: str  # Human-readable explanation of weather conditions
    trading_reason: str  # Human-readable explanation of why this trade is profitable

    # Essential weather data that triggered the signal
    current_temperature_f: Optional[float]
    strike_threshold: Optional[float]

    # Expected profit for execution validation (derived from market vs theoretical)
    expected_profit_cents: Optional[int]

    def __post_init__(self):
        """Validate trading signal data integrity."""
        self._validate_trade_fields()
        self._validate_reason_fields()
        timestamp_value = cast(object, self.timestamp)
        require(
            isinstance(timestamp_value, datetime),
            ValueError("Timestamp must be a datetime object"),
        )

    def _validate_trade_fields(self) -> None:
        """Ensure trading instructions align with the signal type."""
        if self.signal_type in (TradingSignalType.BUY, TradingSignalType.SELL):
            require(
                self.action is not None
                and self.side is not None
                and self.target_price_cents is not None,
                ValueError("BUY/SELL signals must have action, side, and target_price_cents"),
            )
            self._validate_target_price()
            return

        if self.signal_type == TradingSignalType.NO_TRADE:
            require(
                not any((self.action, self.side, self.target_price_cents)),
                ValueError("NO_TRADE signals must not have action, side, or target_price_cents"),
            )

    def _validate_target_price(self) -> None:
        """Ensure the provided target price is within the allowed range."""
        assert self.target_price_cents is not None
        target_price = self.target_price_cents
        require(
            _MIN_PRICE < target_price <= _MAX_PRICE,
            ValueError(f"Target price must be between 1-{_MAX_PRICE} cents: {target_price}"),
        )

    def _validate_reason_fields(self) -> None:
        """Ensure metadata fields are populated."""
        require(bool(self.ticker), ValueError("Ticker must be specified"))
        require(bool(self.weather_reason), ValueError("Weather reason must be specified"))
        require(bool(self.trading_reason), ValueError("Trading reason must be specified"))


@dataclass
class TradingSignalBatch:
    """
    Batch of trading signals generated in a single weather update cycle.

    Allows the weather service to generate multiple signals efficiently
    and provides context about the overall update.
    """

    signals: list[TradingSignal]
    weather_station: str
    update_timestamp: datetime
    total_markets_analyzed: int
    signals_generated: int

    def __post_init__(self):
        """Validate batch data integrity"""
        if self.signals_generated != len(self.signals):
            raise ValueError(
                ERR_SIGNAL_COUNT_MISMATCH.format(
                    generated=self.signals_generated, actual=len(self.signals)
                )
            )

        timestamp_value = cast(object, self.update_timestamp)
        if not isinstance(timestamp_value, datetime):
            raise TypeError(ERR_UPDATE_TIMESTAMP_NOT_DATETIME)

        if self.total_markets_analyzed < 0:
            raise ValueError(ERR_MARKETS_ANALYZED_NEGATIVE)
